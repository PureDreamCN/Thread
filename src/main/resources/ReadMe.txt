sleep()方法（休眠）是线程类（Thread）的静态方法，
    调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，
    但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，
    请参考第66题中的线程状态转换图）。
wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），
    进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），
    如果线程重新获得对象的锁就可以进入就绪状态。

    ① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
    ② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
    ③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
    ④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

  获取锁的线程释放锁只会有两种情况：
    　　1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；

    　　2）线程执行发生异常，此时JVM会让线程自动释放锁。